<!DOCTYPE html>
<html>
<head>
    <title>Controlled Sphere Rotation</title>
    <style>
        canvas {
            background: #000;
            cursor: grab;
        }
        canvas:active {
            cursor: grabbing;
        }
        .instructions {
            position: fixed;
            top: 20px;
            left: 20px;
            color: white;
            font-family: Arial;
        }
    </style>
</head>
<body>
    <div class="instructions">Click and drag to rotate</div>
    <canvas id="sphereCanvas"></canvas>

<script>
const canvas = document.getElementById('sphereCanvas');
const ctx = canvas.getContext('2d');

// Set canvas size
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

// Sphere properties
const config = {
    radius: 100,
    pointSize: 2,  // Smaller dots
    pointCount: 800,
    lightDirection: [0.5, 0.5, 1],
    rotationSpeed: 0.5
};

// Generate sphere points
const points = Array.from({ length: config.pointCount }, () => {
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos((Math.random() * 2) - 1);
    
    return {
        x: config.radius * Math.sin(phi) * Math.cos(theta),
        y: config.radius * Math.sin(phi) * Math.sin(theta),
        z: config.radius * Math.cos(phi)
    };
});

// Rotation state
let isDragging = false;
let startX = 0;
let startY = 0;
let currentRotationX = 0;
let currentRotationZ = 0;

// Rotation functions
function rotateX(point, angle) {
    const y = point.y * Math.cos(angle) - point.z * Math.sin(angle);
    const z = point.y * Math.sin(angle) + point.z * Math.cos(angle);
    return { ...point, y, z };
}

function rotateZ(point, angle) {
    const x = point.x * Math.cos(angle) - point.y * Math.sin(angle);
    const y = point.x * Math.sin(angle) + point.y * Math.cos(angle);
    return { ...point, x, y };
}

function project(point) {
    const depth = 500;
    const factor = depth / (depth - point.z);
    return {
        x: point.x * factor + canvas.width/2,
        y: point.y * factor + canvas.height/2,
        z: point.z
    };
}

// Mouse/touch handlers
function handleStart(e) {
    isDragging = true;
    startX = e.clientX || e.touches[0].clientX;
    startY = e.clientY || e.touches[0].clientY;
}

function handleMove(e) {
    if (!isDragging) return;
    
    const currentX = e.clientX || e.touches[0].clientX;
    const currentY = e.clientY || e.touches[0].clientY;
    
    const deltaX = currentX - startX;
    const deltaY = currentY - startY;
    
    currentRotationZ = deltaX * config.rotationSpeed * (Math.PI / 180);
    currentRotationX = deltaY * config.rotationSpeed * (Math.PI / 180);
    
    drawFrame();
}

function handleEnd() {
    isDragging = false;
}

// Drawing function
function drawFrame() {
    ctx.fillStyle = 'black';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    points.forEach(point => {
        let rotated = rotateZ(point, currentRotationZ);
        rotated = rotateX(rotated, currentRotationX);
        
        const projected = project(rotated);
        
        const light = Math.max(0, 
            (rotated.x * config.lightDirection[0] +
             rotated.y * config.lightDirection[1] +
             rotated.z * config.lightDirection[2]) / config.radius
        );
        
        ctx.beginPath();
        ctx.fillStyle = `hsl(200, 100%, ${light * 70}%)`;
        ctx.arc(projected.x, projected.y, config.pointSize, 0, Math.PI * 2);
        ctx.fill();
    });
}

// Event listeners
canvas.addEventListener('mousedown', handleStart);
canvas.addEventListener('mousemove', handleMove);
canvas.addEventListener('mouseup', handleEnd);
canvas.addEventListener('mouseleave', handleEnd);

canvas.addEventListener('touchstart', handleStart);
canvas.addEventListener('touchmove', handleMove);
canvas.addEventListener('touchend', handleEnd);

// Resize handler
window.addEventListener('resize', () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
});

// Initial draw
drawFrame();
</script>
</body>
</html>