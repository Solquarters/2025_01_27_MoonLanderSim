<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Moon Lander</title>
    <link rel="icon" type="image/x-icon" href="./img/icons8-lander-topaz-16.png">

    <style>
      /* anta-regular - latin */
      @font-face {
        font-display: swap; /* Check https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-display for other options. */
        font-family: "Anta";
        font-style: normal;
        font-weight: 400;
        src: url("../fonts/anta-v1-latin-regular.woff2") format("woff2"); /* Chrome 36+, Opera 23+, Firefox 39+, Safari 12+, iOS 10+ */
      }

      @font-face {
        font-display: swap; /* Check https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/font-display for other options. */
        font-family: "DSEG7Modern";
        font-style: normal;
        font-weight: 400;
        src: url("../fonts/DSEG7Modern-BoldItalic.woff2") format("woff2"); /* Chrome 36+, Opera 23+, Firefox 39+, Safari 12+, iOS 10+ */
      }
      /* Remove any background-image to avoid extra overhead */
      body {
        font-family: "Anta";
        margin: 0;
        padding: 0;
        background: #000;
        overflow: hidden; /* If you don't want scrollbars */
      }
      .canvas-container {
        position: relative;
        width: 1200px;
        height: 800px;
        margin: 10px auto; /* center container if you like */
        border: 1px solid #ccc;
      }
      /* Stack canvases: starryBg at the bottom, flickerCanvas in the middle, gravityCanvas on top */
      #starryBg,
      #flickerCanvas,
      #gravityCanvas {
        position: absolute;
        top: 0;
        left: 0;
        width: 1200px;
        height: 800px;
        display: block;
      }
      /* Optional: ensure the top canvas is above the others */
      #gravityCanvas {
        z-index: 2;
      }
      #flickerCanvas {
        z-index: 1;
      }
      #starryBg {
        z-index: 0;
      }

      #mainHUDId {
        /* pointer-events: none; */
        position: absolute;
        z-index: 10;
        width: 100%;
        height: 100%;
        /* background-color: rgba(0, 255, 255, 0.308); */
      }

      #velocityMainDivId {
        height: 50vh;
        min-height: 300px;
        position: absolute;
        top: 25%;
        left: 5%;
        border: 2px solid rgba(255, 255, 255, 0.829);
        border-radius: 4px;
        width: 48px;
        overflow: hidden;
      }
      #velocityStepsDivId {
        position: absolute;
        display: flex;
        flex-direction: column;
        align-items: center;
        color: white;
        position: relative;
        transition: all 50ms ease-in-out;

        bottom: 0;
        transform: translateY(0);
      }
      .seperator {
        width: 50%;
        height: 2px;
        background-color: white;
        display: flex;
      }
      .seperator2 {
        border: none;
        width: 100%;
        height: 2px;
        background-color: rgba(255, 184, 0, 1);
        display: flex;
        justify-content: center;
      }
      .seperator3 {
        border: none;
        width: 100%;
        background-color: rgb(255, 0, 0);
        display: flex;
        justify-content: center;
      }
      #velIndicatorId {
        z-index: 9;
        position: absolute;
        top: calc(50% - 16px);
        border-top: 2px solid white;
        border-bottom: 2px solid white;
        background-color: rgba(248, 255, 206, 0.384);
        width: 100%;
        height: 32px;
      }
      .single-speed-div-class {
        height: 15vh;
        min-height: 50px;
        width: 100%;
        /* height: 128px; */
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 800;
      }
      .orange-gradient-class {
        background: linear-gradient(
          180deg,
          rgba(255, 184, 0, 1) 0%,
          rgb(153, 92, 0) 50%,
          rgb(0, 0, 0) 100%
        );
      }
      .orange-red-gradient-class {
        background: linear-gradient(
          -180deg,
          rgb(255, 0, 0) 0%,
          rgba(255, 184, 0, 1) 100%
        );
      }
      .red-class {
        background-color: red;
      }
      .green-class {
        background: linear-gradient(
          180deg,
          rgba(0, 0, 0, 1) 0%,
          rgba(0, 255, 0, 1) 100%,
          rgba(0, 255, 0, 1) 100%
        );
      }
      #collisionMainDivId {
        position: absolute;
        bottom: 2%;
        left: calc(50% - 150px);
        border: 4px solid rgba(255, 255, 255, 0.829);
        border-radius: 4px;
        height: 48px;
        width: 300px;
        overflow: hidden;
        color: white;
        font-size: 24px;
        font-weight: 1000;
        display: none;
        justify-content: center;
        align-items: center;
        background-color: #000333;
        animation: warningBlink 1s step-end infinite;
      }

      .signalParentWrapperDivClass {
        position: absolute;
        top: 2%;
        left: calc(50% - 164px);
        border: 4px solid rgba(255, 255, 255, 0.829);
        border-radius: 4px;
        height: 48px;
        overflow: hidden;
        color: white;
        font-size: 24px;
        font-weight: 1000;
        display: flex;
        justify-content: center;
        align-items: center;
        background-color: #000333;
        animation: smoothPulse 2s ease-out infinite;
      }

      .collisionWrapperDiv {
        width: calc(100%);
        height: calc(100% - 10px);
        margin: 4px;
        border-radius: 2px;
        display: flex;
        justify-content: center;
        align-items: center;
        background: radial-gradient(
          circle,
          rgba(255, 162, 0, 1) 25%,
          rgba(255, 0, 0, 1) 100%
        );
      }
      .greenSignalWrapperDiv {
        cursor: pointer;
        width: calc(100%);
        height: calc(100% - 10px);
        margin: 4px;
        padding: 0px 8px;
        border-radius: 2px;
        display: flex;
        justify-content: center;
        align-items: center;
        background: radial-gradient(rgba(9, 255, 0, 1), rgb(4, 107, 0));
      }

      #resetButtonMainDivId {
        display: none;
        text-align: center;
      }
      .resetButtonMainDiv {
      }

      .oxygenMainDivClass {
        position: absolute;
        top: calc(50% - 15%);
        right: 5%;
        border: 2px solid rgba(255, 255, 255, 0.829);
        border-radius: 4px;
        height: 30%;
        width: 24px;
        overflow: hidden;

        display: flex;
        align-items: flex-end;
        justify-content: center;
      }

      .fuelMainDivClass {
        position: absolute;
        top: calc(50% - 15%);
        right: 2.5%;
        border: 2px solid rgba(255, 255, 255, 0.829);
        border-radius: 4px;
        height: 30%;
        width: 24px;
        overflow: hidden;
        display: flex;
        align-items: flex-end;
        justify-content: center;
      }
      .fuelAmountDivClass {
        background: radial-gradient(rgb(255, 255, 255), rgb(0, 0, 0));
        display: flex;
        align-items: flex-end;
        justify-content: center;
        color: white;
        border-top: 1px solid rgb(65, 65, 65);
      }
      .oxygenAmountDivClass {
        /* background: linear-gradient(to bottom, rgb(9, 255, 0, 1) 40%, rgb(255, 0, 0)); */
        background: radial-gradient(rgb(0, 217, 255), rgb(0, 49, 53));
        display: flex;
        align-items: flex-end;
        justify-content: center;
        color: white;
      }
      #oxygenAmountDivId {
        height: 80%;
        border-top: 1px solid rgb(0, 78, 72);
        transition: height 200ms ease-in-out;
      }
      #fuelAmountDivId {
        height: 80%;
        transition: height 200ms ease-in-out;
      }

      .missionTimerMainDivClass {
        color: rgb(81, 255, 0);
      }
      #missionTimerId {
        font-family: "DSEG7Modern";
      }

      #velocityInfoId {
        color: rgb(81, 255, 0);
        font-family: "DSEG7Modern";
      }
      .velocityrMainDivClass {
        color: rgb(81, 255, 0);
      }

      .guidanceComputerInterfaceMainDivClass {
        padding: 8px 16px;
        display: flex;
        gap: 32px;
      }

      @keyframes warningBlink {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.1;
        }
        100% {
          opacity: 1;
        }
      }
      @keyframes smoothPulse {
        0% {
          opacity: 1;
        }
        50% {
          opacity: 0.1;
        }
        100% {
          opacity: 1;
        }
      }
    </style>
  </head>
  <body>
    <div id="mainHUDId" onclick="">
      <div class="oxygenMainDivClass">
        <div class="oxygenAmountDivClass" id="oxygenAmountDivId">
          <span>O²</span>
        </div>
      </div>
      <div class="fuelMainDivClass">
        <div class="fuelAmountDivClass" id="fuelAmountDivId">
          <span>H²</span>
        </div>
      </div>

      <div
        class="resetButtonMainDiv"
        id="resetButtonMainDivId"
        onclick="resetParticle()"
      >
        <div class="signalParentWrapperDivClass">
          <div class="greenSignalWrapperDiv">[SPACE] to resume training</div>
        </div>
      </div>

      <div class="" id="collisionMainDivId">
        <div class="collisionWrapperDiv">ON COLLISION COURSE</div>
      </div>
      <div id="velocityMainDivId">
        <div id="velIndicatorId"></div>
        <div class="" id="velocityStepsDivId">
          <div class="single-speed-div-class red-class">
            <span>5.5</span>
          </div>

          <div class="seperator3">
            <div class="seperator"></div>
          </div>

          <div class="single-speed-div-class red-class">
            <span>4.5</span>
          </div>
          <div class="seperator3">
            <div class="seperator"></div>
          </div>
          <div class="single-speed-div-class orange-red-gradient-class">
            <span>3.5</span>
          </div>

          <div class="seperator2">
            <div class="seperator"></div>
          </div>

          <div class="single-speed-div-class orange-gradient-class">
            <span>2.5</span>
          </div>
          <div class="seperator"></div>
          <div class="single-speed-div-class">
            <span>1.5</span>
          </div>
          <div class="seperator"></div>
          <div class="single-speed-div-class green-class">
            <span>0.5</span>
          </div>
          <div class="seperator"></div>
        </div>
      </div>
    </div>
    <div class="guidanceComputerInterfaceMainDivClass">
      <!-- <button onclick="resetParticle()" style="margin: 10px;">Reset</button> -->
      <div class="velocityrMainDivClass">
        <p>VELOCITY:</p>
        <span id="velocityInfoId"></span> px/frame
      </div>

      <div class="missionTimerMainDivClass">
        <br />
        MISSION TIME:
        <p id="missionTimerId"></p>
      </div>

      <span style="color: white">
        <!-- <br> digitaler timer,rotation der ausrichtung, debugge raumschiff verschwindet im mond, responsiveness...
    <br><b>Missionen:</b> Lande an Stelle X bevor Oxygen leer ist 
    <br> umkreise einmal und fliege nach Korridor 
    <br> lande und starte und lande wieder an X stellen 
    <br> Umkreise in geringstmöglicher Höhe in X Zeit 
    <br> Führe ein Katapult manöver durch, erreiche X speed +treffe einen Korridor mit X Treibstoff
    <br>Mondphasen -->
      </span>
    </div>

    <div class="canvas-container">
      <!-- 1) Static star background -->
      <canvas id="starryBg" width="1200" height="800"></canvas>
      <!-- 2) Flickering stars on top of the static background -->
      <canvas id="flickerCanvas" width="1200" height="800"></canvas>
      <!-- 3) Gravity simulation canvas on top -->
      <canvas id="gravityCanvas" width="1200" height="800"></canvas>
    </div>

    <script>
      /****************************************************
       * PART 1: STATIC BACKGROUND (starryBg)
       ****************************************************/
      const bgCanvas = document.getElementById("starryBg");
      const bgCtx = bgCanvas.getContext("2d");

      // Choose how many static stars to draw
      const STATIC_STAR_COUNT = 3000;

      function drawStaticStars() {
        for (let i = 0; i < STATIC_STAR_COUNT; i++) {
          const x = Math.random() * bgCanvas.width;
          const y = Math.random() * bgCanvas.height;
          const radius = Math.random() * 0.4 + 0.01;
          bgCtx.beginPath();
          bgCtx.arc(x, y, radius, 0, 2 * Math.PI);
          bgCtx.fillStyle = "white";
          bgCtx.fill();
        }
      }

      // Draw static stars once
      drawStaticStars();

      /****************************************************
       * PART 2: FLICKER LAYER (flickerCanvas)
       ****************************************************/
      const flickerCanvas = document.getElementById("flickerCanvas");
      const flickerCtx = flickerCanvas.getContext("2d");

      const FLICKER_STAR_COUNT = 1000; // much smaller subset for flicker
      const FLICKER_INTENSITY = 0.1;
      const flickerStars = [];

      // Create small set of flicker stars
      function createFlickerStars() {
        for (let i = 0; i < FLICKER_STAR_COUNT; i++) {
          flickerStars.push({
            x: Math.random() * flickerCanvas.width,
            y: Math.random() * flickerCanvas.height,
            radius: Math.random() * 0.7 + 0.3,
            opacity: Math.random(),
          });
        }
      }

      // Draw flicker stars (low-FPS)
      function drawFlickerStars() {
        // Clear just this flicker canvas each frame
        flickerCtx.clearRect(0, 0, flickerCanvas.width, flickerCanvas.height);

        flickerStars.forEach((star) => {
          // Update opacity for flicker
          star.opacity +=
            Math.random() * FLICKER_INTENSITY * 2 - FLICKER_INTENSITY;
          if (star.opacity > 1) star.opacity = 1;
          if (star.opacity < 0) star.opacity = 0;

          flickerCtx.beginPath();
          flickerCtx.arc(star.x, star.y, star.radius, 0, 2 * Math.PI);
          flickerCtx.fillStyle = `rgba(255,255,255,${star.opacity})`;
          flickerCtx.fill();
        });
      }

      // Animate flicker at ~20 FPS to reduce CPU usage
      function animateFlicker() {
        setTimeout(() => {
          requestAnimationFrame(animateFlicker);
          drawFlickerStars();
        }, 1000 / 20);
      }

      // Init flicker stars & start flicker loop
      createFlickerStars();
      animateFlicker();

      /****************************************************
       * PART 3: GRAVITY/ORBIT SIMULATION (gravityCanvas)
       ****************************************************/
      const canvas = document.getElementById("gravityCanvas");
      const ctx = canvas.getContext("2d");

      // Create an image instance for the center mass
      const centerMassImage = new Image();
      centerMassImage.src = "./img/full-moon_640.jpg"; // Replace with your image path

      function drawCenterMassWithImage(obj) {
        if (centerMassImage.complete) {
          ctx.save();
          // 1. Clip the canvas to the circular shape of the center mass
          ctx.beginPath();
          ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI * 2);
          ctx.closePath();
          ctx.clip();

          // 2. Draw a larger image centered at the center mass
          const scaleFactor = 1.18;
          const imageWidth = obj.radius * 2 * scaleFactor;
          const imageHeight = obj.radius * 2 * scaleFactor;

          ctx.drawImage(
            centerMassImage,
            obj.x - imageWidth / 2,
            obj.y - imageHeight / 2,
            imageWidth,
            imageHeight
          );

          // 3. Restore the context to remove the clipping
          ctx.restore();
        } else {
          // If the image isn't loaded yet, draw a fallback circle
          drawObject(obj, "black");
        }
      }

      // Track which keys are currently pressed
      const keysPressed = {
        ArrowLeft: false,
        ArrowRight: false,
        ArrowUp: false,
        ArrowDown: false,
      };

      // Listen for keydown/keyup
      document.addEventListener("keydown", (e) => {
        if (e.key in keysPressed) {
          keysPressed[e.key] = true;
        }
      });
      document.addEventListener("keyup", (e) => {
        if (e.key in keysPressed) {
          keysPressed[e.key] = false;
        }
        if (
          !keysPressed.ArrowLeft &&
          !keysPressed.ArrowRight &&
          !keysPressed.ArrowUp &&
          !keysPressed.ArrowDown
        ) {
          // Once thrust is truly finished, recalc the future path:
          futurePath = calculateFuturePath();
        }
        if (event.code === "Space") {
          resetParticle();
        }
      });

      // Center mass and particle
      const centerMass = {
        x: canvas.width / 2,
        y: canvas.height / 2,
        radius: 95,
        mass: 2600,
      };

      const particle = {
        x: 50,
        y: 20,
        radius: 6,
        mass: 0.5,
        vx: 0,
        vy: 0,
        thrust: {
          active: false,
          direction: 0,
          timer: 0,
        },
      };

      // Constants
      const G = 0.5;
      const THRUST_FORCE = 0.07;
      const THRUST_DISPLAY_TIME = 15;

      let lastMousePos = { x: 0, y: 0 };
      let currentMousePos = { x: 0, y: 0 };

      // Trace for particle positions
      const trace = [];
      const MAX_TRACE_LENGTH = 300;

      function drawObject(obj, color) {
        ctx.beginPath();
        ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
      }

      function drawThrust(particle) {
        if (particle.thrust.timer > 0) {
          ctx.save();
          ctx.translate(particle.x, particle.y);
          ctx.rotate(particle.thrust.direction);

          ctx.beginPath();
          ctx.moveTo(-particle.radius, 0);
          ctx.lineTo(-particle.radius - 15, -5);
          ctx.lineTo(-particle.radius - 20, 0);
          ctx.lineTo(-particle.radius - 15, 5);
          ctx.closePath();

          ctx.fillStyle = "orange";
          ctx.fill();

          ctx.restore();
          particle.thrust.timer--;
        }
      }

      let debris = [];

      // Modify the calculateGravity function
      function calculateGravity() {
        const dx = centerMass.x - particle.x;
        const dy = centerMass.y - particle.y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Check for collision
        if (distance < centerMass.radius + particle.radius) {
          const collisionSpeed = getVelocityMaginute(particle.vx, particle.vy);
          if (collisionSpeed >= COLLISION_SPEED_THRESHOLD) {
            explodeParticle(collisionSpeed, particle.vx, particle.vy);

            deleteCollisionWarningButton();
            displayResetButton();
          } else {
            particle.vx = 0;
            particle.vy = 0;
          }
          return;
        }

        // Original gravity calculations
        const force =
          (G * (centerMass.mass * particle.mass)) / (distance * distance);
        const angle = Math.atan2(dy, dx);

        particle.vx += force * Math.cos(angle);
        particle.vy += force * Math.sin(angle);
      }
      // Add new explosion function
      function explodeParticle(collisionSpeed, particlevx, particlevy) {
        particle.isActive = false;

        // Create debris pieces
        const numDebris = Math.floor(Math.random() * 11) + 100; // 20-30 pieces
        for (let i = 0; i < numDebris; i++) {
          debris.push({
            x: particle.x,
            y: particle.y,
            vx: (Math.random() - 0.5 + particlevx * 0.02) * collisionSpeed,
            vy: (Math.random() - 0.5 + particlevy * 0.02) * collisionSpeed,
            radius: Math.random(),
            mass: 0.1,
            color: `rgb(0, 204, 255)`,
            isActive: true,
          });
        }
      }

      function displayResetButton() {
        document.getElementById("resetButtonMainDivId").style.display = "flex";
      }
      function hideDisplayButton() {
        document.getElementById("resetButtonMainDivId").style.display = "none";
      }

      function applyThrust(direction) {
        particle.thrust.active = true;
        particle.thrust.direction = direction;
        particle.thrust.timer = THRUST_DISPLAY_TIME;

        particle.vx += THRUST_FORCE * Math.cos(direction);
        particle.vy += THRUST_FORCE * Math.sin(direction);
      }

      // Draw a fade-like trace behind the particle
      function drawTrace() {
        if (trace.length < 2) return;
        for (let i = 0; i < trace.length - 1; i++) {
          let t = i / (trace.length - 1); // 0..1
          let alpha = t / 1.5; // older => more transparent
          let lineWidth = 0.1 + 2 * t; // older => thinner

          ctx.beginPath();
          ctx.moveTo(trace[i].x, trace[i].y);
          ctx.lineTo(trace[i + 1].x, trace[i + 1].y);
          ctx.strokeStyle = `rgba(255,255,255,${alpha})`;
          ctx.lineWidth = lineWidth;
          ctx.stroke();
        }
      }

      // Show flickering thrust-triangles near the particle if keys are pressed
      function drawThrustIndicators(p) {
        const flickerAlpha = 0.3 + 0.5 * Math.random();
        ctx.fillStyle = `rgba(255, 255, 0, ${flickerAlpha})`;
        const offset = p.radius + 5;

        // Up
        if (keysPressed.ArrowUp) {
          ctx.beginPath();
          ctx.moveTo(p.x, p.y + offset);
          ctx.lineTo(p.x - 5, p.y + offset + 8);
          ctx.lineTo(p.x + 5, p.y + offset + 8);
          ctx.closePath();
          ctx.fill();
        }
        // Down
        if (keysPressed.ArrowDown) {
          ctx.beginPath();
          ctx.moveTo(p.x, p.y - offset);
          ctx.lineTo(p.x - 5, p.y - offset - 8);
          ctx.lineTo(p.x + 5, p.y - offset - 8);
          ctx.closePath();
          ctx.fill();
        }
        // Right
        if (keysPressed.ArrowRight) {
          ctx.beginPath();
          ctx.moveTo(p.x - offset, p.y);
          ctx.lineTo(p.x - offset - 8, p.y - 5);
          ctx.lineTo(p.x - offset - 8, p.y + 5);
          ctx.closePath();
          ctx.fill();
        }
        // Left
        if (keysPressed.ArrowLeft) {
          ctx.beginPath();
          ctx.moveTo(p.x + offset, p.y);
          ctx.lineTo(p.x + offset + 8, p.y - 5);
          ctx.lineTo(p.x + offset + 8, p.y + 5);
          ctx.closePath();
          ctx.fill();
        }
      }

      // Modify the update function to handle debris
      function update() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        if (particle.isActive) {
          calculateGravity();

          if (!missionTimer.running) {
            missionTimer.start(); // Start the timer if it hasn't started
          }

          // Existing movement code
          let thrustX = 0,
            thrustY = 0;
          const isThrusting = Object.values(keysPressed).some((key) => key);

          // Only apply thrust if we have fuel
          if (updateFuel(missionTimer.getTime(), isThrusting)) {
            if (keysPressed.ArrowLeft) thrustX -= THRUST_FORCE;
            if (keysPressed.ArrowRight) thrustX += THRUST_FORCE;
            if (keysPressed.ArrowUp) thrustY -= THRUST_FORCE;
            if (keysPressed.ArrowDown) thrustY += THRUST_FORCE;

            particle.vx += thrustX;
            particle.vy += thrustY;
          }

          particle.x += particle.vx;
          particle.y += particle.vy;
        } else {
          missionTimer.stop();
        }

        debris.forEach((debrisPiece, index) => {
          // If already landed, skip gravity/velocity:
          if (debrisPiece.landed) {
            return;
          }

          // ... otherwise do the usual gravity stuff ...
          const dx = centerMass.x - debrisPiece.x;
          const dy = centerMass.y - debrisPiece.y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          // If debris intersects the planet:
          if (distance <= centerMass.radius + debrisPiece.radius) {
            // Snap to surface, set velocity = 0, mark landed
            const angle = Math.atan2(dy, dx);
            debrisPiece.x =
              centerMass.x -
              (centerMass.radius + debrisPiece.radius) * Math.cos(angle);
            debrisPiece.y =
              centerMass.y -
              (centerMass.radius + debrisPiece.radius) * Math.sin(angle);
            debrisPiece.vx = 0;
            debrisPiece.vy = 0;
            debrisPiece.landed = true;
          } else {
            // Otherwise apply gravity as normal
            const force =
              (G * (centerMass.mass * debrisPiece.mass)) /
              (distance * distance);
            const angle = Math.atan2(dy, dx);
            debrisPiece.vx += force * Math.cos(angle);
            debrisPiece.vy += force * Math.sin(angle);
            debrisPiece.x += debrisPiece.vx;
            debrisPiece.y += debrisPiece.vy;
          }
        });

        // Keep track of trail
        trace.push({ x: particle.x, y: particle.y });
        if (trace.length > MAX_TRACE_LENGTH) {
          trace.shift();
        }

        // Draw all elements
        drawTrace();
        drawCenterMassWithImage(centerMass);

        // Draw particle if active
        if (particle.isActive) {
          drawObject(particle, "blue");
          drawThrustIndicators(particle);
        }

        // Draw debris
        debris.forEach((debrisPiece) => {
          drawObject(debrisPiece, debrisPiece.color);
        });

        drawFuturePath();
        drawVelocityInfo(particle.vx, particle.vy);

        // Update timer display each frame
        missionTimer.updateDisplay();

        reduceOxygenAmount(missionTimer.getTime());

        requestAnimationFrame(update);
      }

      function drawVelocityInfo(vx, vy) {
        currentVelocity = getVelocityMaginute(vx, vy);
        // calc magnitude of velocity:
        let velocityMagnitude = getVelocityMaginute(vx, vy);

        let pElement = document.getElementById("velocityInfoId");
        updateVelocityHUD(velocityMagnitude);

        // Split the number into whole and decimal parts
        let wholePart = Math.floor(velocityMagnitude);
        let decimalPart = (velocityMagnitude - wholePart)
          .toFixed(2)
          .substring(2);

        // Combine with dot separator
        pElement.textContent = `${wholePart} . ${decimalPart}`;
      }

      const OXYGEN_REDUCTION_RATE = 0.5; // % per second
      let lastOxygenUpdate = 0;

      function reduceOxygenAmount(elapsedTime) {
        // Only reduce oxygen if particle is active
        if (!particle.isActive) return;

        const currentSecond = Math.floor(elapsedTime / 1000);

        if (currentSecond > lastOxygenUpdate) {
          let oxygenContainer = document.getElementById("oxygenAmountDivId");
          let currentPercentage =
            parseFloat(oxygenContainer.style.height) || 80; // Default to 80 if not set

          // Reduce by rate and ensure we don't go below 0
          let newPercentage = Math.max(
            0,
            currentPercentage - OXYGEN_REDUCTION_RATE
          );
          oxygenContainer.style.height = newPercentage + "%";

          lastOxygenUpdate = currentSecond;

          // Check if oxygen is depleted
          if (newPercentage <= 0) {
            // Handle oxygen depletion
            particle.isActive = false;
            missionTimer.stop();
            displayResetButton();
          }
        }
      }

      /////////Fuel Reduction Start /////////

      const FUEL_REDUCTION_RATE = 0.6; // % per 0.1 second
      let lastFuelUpdateTime = 0;

      function getFuelLevel() {
        let fuelContainer = document.getElementById("fuelAmountDivId");
        return parseFloat(fuelContainer.style.height) || 80;
      }

      function setFuelLevel(level) {
        let fuelContainer = document.getElementById("fuelAmountDivId");
        fuelContainer.style.height = Math.max(0, level) + "%";
      }

      function updateFuel(currentTime, isThrusting) {
        if (!isThrusting) return true;

        const currentTenth = Math.floor(currentTime / 100);
        const currentFuel = getFuelLevel();

        if (currentFuel <= 0) return false;

        if (currentTenth > lastFuelUpdateTime) {
          setFuelLevel(currentFuel - FUEL_REDUCTION_RATE);
          lastFuelUpdateTime = currentTenth;
        }

        return currentFuel > 0;
      }
      /////////Fuel Reduction End /////////

      // function updateVelocityHUD(velocityMagnitude) {
      //   let HUDPosition = document.getElementById("velocityStepsDivId");
      //   HUDPosition.style.bottom = `${-velocityMagnitude * 128 + 512}px`;
      // }
      // Modified updateVelocityHUD function
      function updateVelocityHUD(velocityMagnitude) {
        const velocityStepsDiv = document.getElementById("velocityStepsDivId");
        const container = document.getElementById("velocityMainDivId");

        // Get fresh measurements each time
        const stepHeight = document.querySelector(
          ".single-speed-div-class"
        ).offsetHeight;
        const containerHeight = container.offsetHeight;

        const baseOffset = containerHeight+stepHeight+4;
        const translateYValue =
          (baseOffset - velocityMagnitude * stepHeight) * -1;

        velocityStepsDiv.style.transform = `translateY(${translateYValue}px)`;
      }

      function getVelocityMaginute(vx, vy) {
        let velocityMagnitude = Math.sqrt(vx * vx + vy * vy);
        return velocityMagnitude;
      }
      // Reset particle
      // Update the reset function
      function resetParticle() {
        particle.x = 600;
        particle.y = 280;
        particle.vx = 0;
        particle.vy = 0;

        particle.thrust.active = false;
        particle.thrust.timer = 0;
        particle.isActive = true;
        trace.length = 0;
        debris = [];
        futurePath = calculateFuturePath();

        // Reset oxygen level
        let oxygenContainer = document.getElementById("oxygenAmountDivId");
        oxygenContainer.style.height = "80%";
        lastOxygenUpdate = 0;

        //Reset fuelLevel
        setFuelLevel(80);
        lastFuelUpdateTime = 0;

        if (missionTimer) {
          missionTimer.reset();
          // missionTimer.start();
        }

        hideDisplayButton();
      }

      /****************************************************
       * PART 4: FUTURE PATH PROJECTION
       ****************************************************/
      let futurePath = []; // Array of {x, y} points for future path
      let collisionPoint = null; // Store the collision point
      let collisionSpeed = 0; // Store the speed at collision
      const COLLISION_SPEED_THRESHOLD = 1.5; // Tweak this value as needed

      function calculateFuturePath() {
        if (!particle.isActive) return [];
        // Backup current real state
        const backup = {
          x: particle.x,
          y: particle.y,
          vx: particle.vx,
          vy: particle.vy,
        };

        const tempPath = [];
        const steps = 3000; // Number of steps to predict
        const dt = 1; // Time increment, e.g., "1 frame’s worth"

        collisionPoint = null; // Reset collision point
        collisionSpeed = 0; // Reset collision speed

        // Simulate forward in small steps
        for (let i = 0; i < steps; i++) {
          // Apply gravity 
          const dx = centerMass.x - particle.x;
          const dy = centerMass.y - particle.y;
          const dist = Math.sqrt(dx * dx + dy * dy);
          const force = (G * (centerMass.mass * particle.mass)) / (dist * dist);
          const angle = Math.atan2(dy, dx);
          particle.vx += force * Math.cos(angle) * dt;
          particle.vy += force * Math.sin(angle) * dt;

          // Update position
          particle.x += particle.vx * dt;
          particle.y += particle.vy * dt;

          // Check for collision
          if (dist < centerMass.radius + particle.radius) {
            collisionPoint = { x: particle.x, y: particle.y };
            collisionSpeed = Math.sqrt(
              particle.vx * particle.vx + particle.vy * particle.vy
            ); 

            document.getElementById("collisionMainDivId").style.display =
              "flex";
            break; // Stop simulating further
          }
          document.getElementById("collisionMainDivId").style.display = "none";
          // Push to path array
          tempPath.push({ x: particle.x, y: particle.y });
        }

        // Restore the real simulation state
        particle.x = backup.x;
        particle.y = backup.y;
        particle.vx = backup.vx;
        particle.vy = backup.vy;

        // Return predicted future path
        return tempPath;
      }

      // Draw the future path and collision indicator
      function drawFuturePath() {
        if (futurePath.length === 0) return;

        // Draw the future path
        ctx.beginPath();
        ctx.moveTo(futurePath[0].x, futurePath[0].y);
        for (let i = 1; i < futurePath.length; i++) {
          ctx.lineTo(futurePath[i].x, futurePath[i].y);
        }

        // Set path color based on collision speed
        if (collisionPoint) {
          if (collisionSpeed >= COLLISION_SPEED_THRESHOLD) {
            ctx.strokeStyle = "rgba(255, 0, 0, 0.6)"; // Red for high-speed collision
          } else {
            ctx.strokeStyle = "rgba(0, 255, 0, 0.6)"; // Green for low-speed collision
          }
        } else {
          ctx.strokeStyle = "rgba(255, 255, 0, 0.6)"; // Default yellow for no collision
        }

        ctx.setLineDash([2, 3]);
        ctx.lineWidth = 1.5;
        ctx.stroke();
        ctx.setLineDash([]); // Reset dash

        // Draw collision indicator
        if (collisionPoint && particle.isActive) {
          if (collisionSpeed >= COLLISION_SPEED_THRESHOLD) {
            // Draw red "X" for high-speed collision
            ctx.fillStyle = "red";
            ctx.font = "20px Arial";
            ctx.fillText("💥", collisionPoint.x - 10, collisionPoint.y + 10);
            document.getElementById("collisionMainDivId").style.display =
              "flex";
          } else {
            // Draw green circle for low-speed collision

            ctx.fillStyle = "green";
            ctx.beginPath();
            ctx.arc(collisionPoint.x, collisionPoint.y, 4, 0, Math.PI * 2);
            ctx.fill();

            deleteCollisionWarningButton();
          }
        }
      }

      function deleteCollisionWarningButton() {
        document.getElementById("collisionMainDivId").style.display = "none";
      }

      /****************************************************
       * PART 5: MISSION TIMER
       ****************************************************/
      class MissionTimer {
        constructor(displayElementId) {
          this.displayElement = document.getElementById(displayElementId);
          this.startTime = 0;
          this.elapsedTime = 0;
          this.running = false;
          this.intervalId = null;
        }

        start() {
          if (!this.running) {
            this.startTime = performance.now() - this.elapsedTime;
            this.running = true;
            this.updateDisplay();
          }
        }

        stop() {
          if (this.running) {
            this.elapsedTime = performance.now() - this.startTime;
            this.running = false;
          }
        }

        reset() {
          this.startTime = performance.now();
          this.elapsedTime = 0;
          this.running = true;
          this.updateDisplay();
        }

        getTime() {
          return this.running
            ? performance.now() - this.startTime
            : this.elapsedTime;
        }

        getFormattedTime() {
          let time = this.getTime();
          let milliseconds = Math.floor(time % 1000);
          let seconds = Math.floor((time / 1000) % 60);
          let minutes = Math.floor((time / (1000 * 60)) % 60);
          let hours = Math.floor(time / (1000 * 60 * 60));

          return (
            `${hours.toString().padStart(2, "0")}:` +
            `${minutes.toString().padStart(2, "0")}:` +
            `${seconds.toString().padStart(2, "0")} . ` +
            `${milliseconds.toString().padStart(3, "0")}`
          );
        }

        updateDisplay() {
          if (this.displayElement) {
            this.displayElement.textContent = this.getFormattedTime();
          }
          if (this.running) {
            requestAnimationFrame(() => this.updateDisplay()); // Ensures smooth updating
          }
        }
      }

      // Initialize the mission timer
      const missionTimer = new MissionTimer("missionTimerId");

      /// MISSION TIMER END ///

      let currentVelocity = 0;

      // window.addEventListener('resize', () => {
      //   updateVelocityHUD(currentVelocity);
      // });

      ///For resizing and to scale velocity
      document.addEventListener("DOMContentLoaded", () => {
        // Initial positioning
        updateVelocityHUD(0);
        window.dispatchEvent(new Event("resize"));
      });

      // Start the gravity simulation
      update();
      resetParticle();
      futurePath = calculateFuturePath();
    </script>
  </body>
</html>
